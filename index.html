<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.2/d3.min.js" integrity="sha512-oKI0pS1ut+mxQZdqnD3w9fqArLyILRsT3Dx0B+8RVEXzEk3aNK3J3pWlaGJ8MtTs1oiwyXDAH6hG6jy1sY0YqA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <svg id="chart"></svg>
    <script>
        const svg = d3.select('#chart')

        const width = parseInt(svg.style('width'));
        const height = parseInt(svg.style('height'));

        const margin = {top: 10, right: 10, bottom: 40, left: 50}

        const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`)

        
        const xScale = d3.scaleLinear().range([0, width - margin.left - margin.right])
        const yScale = d3.scaleLinear().range([height - margin.top - margin.bottom, margin.top])
        const rScale = d3.scaleSqrt().range([5, 15])
        const opacityScale = d3.scaleLinear().range([0.4, 0.9])

        // function createPolygonalPath(n, up=true) {
        //     let theta = -Math.PI/n
        //     let x = 0
        //     let y = 1/(2*n*Math.sin(Math.PI/n)) * (up ? -1 : 1)
        //     let path = `M${x}, ${y} `
            
        //     for (let i = 0; i < n-1; i++) {
        //         theta += 2*Math.PI/n;
        //         x = Math.cos(theta)/n
        //         y = Math.sin(theta)/n * (up ? 1 : -1)
        //         path += ` l${x},${y}`
        //     }
            
        //     return path
        // }

        function createPolygonalPath(n, up=true) {
            let index = [...Array(n).fill(0).map((_, i) => i)]
            let points = index.map(i => { 
                return {
                    x: Math.cos(i*2*Math.PI/n + 0.5*(up ? -1 : 1) * Math.PI), 
                    y: Math.sin(i*2*Math.PI/n + 0.5*(up ? -1 : 1) * Math.PI)
                }; 
            })

            return points.map((p, i) => `${i == 0 ? 'M' : 'L'}${p.x},${p.y} ${i === n-1 ? 'Z' : ''}`).join('')
        }

        function createStarPath(n, radiiRatio = 0.5, up = true) {
            let index = [...Array(2*n).fill(0).map((_, i) => i)]
            let points = index.map(i => { 
                return {
                    x: (i % 2 == 0 ? 1 : radiiRatio) * Math.cos(i*Math.PI/n + 0.5*(up ? -1 : 1) * Math.PI), 
                    y: (i % 2 == 0 ? 1 : radiiRatio) * Math.sin(i*Math.PI/n + 0.5*(up ? -1 : 1) * Math.PI)
                }; 
            })

            return points.map((p, i) => `${i == 0 ? 'M' : 'L'}${p.x},${p.y} ${i === 2*n-1 ? 'Z' : ''}`).join('')
        }

        const shapes = ['circle', 'triangleUp', 'diamond', 'pentagon', 'star5', 'hexagon', 'star6', 'octagon', 'triangleDown']

        const shapePaths = {
            circle: createPolygonalPath(64),
            triangleUp: createPolygonalPath(3),
            triangleDown: createPolygonalPath(3, false),
            diamond: createPolygonalPath(4),
            pentagon: createPolygonalPath(5),
            hexagon: createPolygonalPath(6),
            octagon: createPolygonalPath(8),
            star4: createStarPath(4),
            star5: createStarPath(5),
            star6: createStarPath(6),
        }
        
        // const url = 'https://www.omscentral.com/_next/data/RbJpKU_7gp7Gm26pP9748/index.json'
        const url = './index.json'

        d3.json(url).then(data => {
            const courseData = d3.sort(data.pageProps.courses, x => x.reviewCount)
            courseData.forEach(course => {
                const re = /(\w*)-/
                const code = re.exec((course.codes[0]))[1]
                course.code = code
            })

            console.log(courseData)
            
            xScale.domain([0.75, 5])
            yScale.domain([1.75, 5])
            rScale.domain(d3.extent(courseData, x => x.workload))
            opacityScale.domain(d3.extent(courseData, x => x.reviewCount))
            const codes = new Set(courseData.map(x => /(\w*)-/.exec((x.codes[0]))[1]))
            const codeShape = {}
            
            const hues = {}
            Array.from(codes).forEach((code, i, s) => {
                hues[code] = 360 * i / s.length
                codeShape[code] = shapes[i]
            })
            console.log(codeShape)

            const xAxis = d3.axisBottom(xScale)
            const yAxis = d3.axisLeft(yScale)

            const xMedian = d3.median(courseData, x => x.rating)
            const yMedian = d3.median(courseData, x => x.difficulty)

            

            g.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0, ${height - margin.top - margin.bottom})`)
                .call(xAxis)
                .append('text')
                .text('Difficulty')
                .attr('transform', `translate(${width/2}, ${margin.bottom - 5})`)

            g.append('g')
                .attr('class', 'axis')
                //.attr('transform', `translate(0, 30)`)
                .call(yAxis)

            g.append('rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', d3.max(xScale.range()))
                .attr('height', yScale(yMedian))
                .attr('fill', 'hsla(240, 0%, 15%, 0.5)')

            g.append('rect')
                .attr('x', xScale(xMedian))
                .attr('y', 0)
                .attr('width', d3.max(xScale.range()) - xScale(xMedian))
                .attr('height', d3.max(yScale.range()))
                .attr('fill', 'hsla(240, 0%, 15%, 0.5)')


            function makePoint(node, i) {
                d = node.data()[i]
                console.log(node, i)
                                
                const shape = codeShape[d.code]
                console.log(d.code, shape)

                let shapeNode

                if (shape == 'circle') {
                    shapeNode = node.append('circle')
                    shapeNode
                        .attr('cx', d => xScale(+d.difficulty))
                        .attr('cy', d => yScale(+d.rating))
                        .attr('r', d => rScale(+d.workload))
                } else {
                    shapeNode = node.append('path')
                    shapeNode
                        .attr('d', shapePaths[shape])
                        .attr('transform', `translate(${xScale(+d.difficulty), yScale(+d.rating)}) scale(${rScale(+d.workload)})`)
                }

                shapeNode

            }

            const bubbles = g.selectAll('.course').data(courseData).enter().append('path')
                .attr('class', 'course')
                .attr('d', d => shapePaths[codeShape[d.code]])
                .attr('transform', d => `translate(${xScale(+d.difficulty)}, ${yScale(+d.rating)}) scale(${rScale(+d.workload)})`)
                .attr('stroke', d => d.isFoundational ? `hsl(${hues[d.code]}, 100%, 85%)` : 'none')
                .attr('stroke-width', d => 1/rScale(+d.workload))
                .attr('fill', d => {
                    let hue = hues[d.code]
                    return `hsla(${hue}, 100%, 50%, ${opacityScale(d.reviewCount)})`
                })



            // g.selectAll('.test').data([3, 4, 5, 6, 7, 8]).enter().append('path')
            //         .attr('d', n => createStarPath(n))
            //         .attr('transform', n => `translate(${xScale(n/2)}, ${yScale((n-3)/2 + 2)}), scale(20)`)
            //         .attr('fill', 'red')

            // g.selectAll('.test').data([3, 4, 5, 6, 7, 8]).enter().append('circle')
            //     .attr('cx', 0)
            //     .attr('cy', 0)
            //     .attr('r', 5)
            //     .attr('transform', n => `translate(${xScale(n/2)}, ${yScale((n-3)/2 + 2)})`)
            //     .attr('fill', 'white')

            bubbles.enter().append(d => {
                const shape = codeShape[d.code];
                return (shape === 'circle' ? 'circle' : 'path')
            })
                .attr('class', 'course')
                
                
                
                .attr('stroke', d => d.isFoundational ? 'white' : 'none')
                .attr('stroke-width', '1')
                .attr('fill', d => {
                    let hue = hues[d.code]
                    return `hsla(${hue}, 100%, 50%, ${opacityScale(d.reviewCount)})`
                })
            })

    </script>
</body>
</html>